{"version":3,"file":"index.umd.js","sources":["../src/types.ts","../src/converters.ts","../src/validators.ts","../src/index.ts"],"sourcesContent":["import { Signer, JWTVerified, JWTHeader, JWTOptions } from 'did-jwt'\n\nexport const JWT_ALG = 'ES256K'\nexport const DID_FORMAT = /^did:([a-zA-Z0-9_]+):([:[a-zA-Z0-9_.-]+)(\\/[^#]*)?(#.*)?$/\nexport const JWT_FORMAT = /^[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+/=]*$/\nexport const DEFAULT_CONTEXT = 'https://www.w3.org/2018/credentials/v1'\nexport const DEFAULT_VC_TYPE = 'VerifiableCredential'\nexport const DEFAULT_VP_TYPE = 'VerifiablePresentation'\nexport const DEFAULT_JWT_PROOF_TYPE = 'JwtProof2020'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type JwtCredentialSubject = Record<string, any>\n\nexport interface CredentialStatus {\n  id: string\n  type: string\n}\n\n/**\n * A JWT payload representation of a Credential\n * @see https://www.w3.org/TR/vc-data-model/#jwt-encoding\n */\nexport interface JwtCredentialPayload {\n  iss?: string\n  sub?: string\n  vc: Extensible<{\n    '@context': string[] | string\n    type: string[] | string\n    credentialSubject: JwtCredentialSubject\n    credentialStatus?: CredentialStatus\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    evidence?: any\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    termsOfUse?: any\n  }>\n  nbf?: number\n  aud?: string | string[]\n  exp?: number\n  jti?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\n/**\n * A JWT payload representation of a Presentation\n * @see https://www.w3.org/TR/vc-data-model/#jwt-encoding\n */\nexport interface JwtPresentationPayload {\n  vp: Extensible<{\n    '@context': string[] | string\n    type: string[] | string\n    verifiableCredential?: VerifiableCredential[] | VerifiableCredential\n  }>\n  iss?: string\n  aud?: string | string[]\n  nbf?: number\n  exp?: number\n  jti?: string\n  nonce?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport type IssuerType = Extensible<{ id: string }> | string\nexport type DateType = string | Date\n/**\n * used as input when creating Verifiable Credentials\n */\ninterface FixedCredentialPayload {\n  '@context': string | string[]\n  id?: string\n  type: string | string[]\n  issuer: IssuerType\n  issuanceDate: DateType\n  expirationDate?: DateType\n  credentialSubject: Extensible<{\n    id?: string\n  }>\n  credentialStatus?: CredentialStatus\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  evidence?: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  termsOfUse?: any\n}\n\n/**\n * A more flexible representation of a {@link W3CCredential} that can be used as input to methods\n * that expect it.\n */\nexport type CredentialPayload = Extensible<FixedCredentialPayload>\n\n/**\n * This is meant to reflect unambiguous types for the properties in `CredentialPayload`\n */\ninterface NarrowCredentialDefinitions {\n  '@context': string[]\n  type: string[]\n  issuer: Exclude<IssuerType, string>\n  issuanceDate: string\n  expirationDate?: string\n}\n\n/**\n * Replaces the matching property types of T with the ones in U\n */\ntype Replace<T, U> = Omit<T, keyof U> & U\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Extensible<T> = T & { [x: string]: any }\n\n/**\n * This data type represents a parsed VerifiableCredential.\n * It is meant to be an unambiguous representation of the properties of a Credential and is usually the result of a transformation method.\n *\n * `issuer` is always an object with an `id` property and potentially other app specific issuer claims\n * `issuanceDate` is an ISO DateTime string\n * `expirationDate`, is a nullable ISO DateTime string\n *\n * Any JWT specific properties are transformed to the broader W3C variant and any app specific properties are left intact\n */\nexport type W3CCredential = Extensible<Replace<FixedCredentialPayload, NarrowCredentialDefinitions>>\n\n/**\n * used as input when creating Verifiable Presentations\n */\nexport interface FixedPresentationPayload {\n  '@context': string | string[]\n  type: string | string[]\n  id?: string\n  verifiableCredential?: VerifiableCredential[]\n  holder: string\n  verifier?: string | string[]\n  issuanceDate?: string\n  expirationDate?: string\n}\n\n/**\n * A more flexible representation of a {@link W3CPresentation} that can be used as input to methods\n * that expect it.\n */\nexport type PresentationPayload = Extensible<FixedPresentationPayload>\n\ninterface NarrowPresentationDefinitions {\n  '@context': string[]\n  type: string[]\n  verifier: string[]\n  verifiableCredential?: Verifiable<W3CCredential>[]\n}\n\n/**\n * This data type represents a parsed Presentation payload.\n * It is meant to be an unambiguous representation of the properties of a Presentation and is usually the result of a transformation method.\n *\n * The `verifiableCredential` array should contain parsed `Verifiable<Credential>` elements.\n * Any JWT specific properties are transformed to the broader W3C variant and any other app specific properties are left intact.\n */\nexport type W3CPresentation = Extensible<Replace<FixedPresentationPayload, NarrowPresentationDefinitions>>\n\nexport interface Proof {\n  type?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\n/**\n * Represents a readonly representation of a verifiable object, including the {@link Proof}\n * property that can be used to verify it.\n */\nexport type Verifiable<T> = Readonly<T> & { readonly proof: Proof }\nexport type JWT = string\n\n/**\n * A union type for both possible representations of a Credential (JWT and W3C standard)\n *\n * @see https://www.w3.org/TR/vc-data-model/#proof-formats\n */\nexport type VerifiableCredential = JWT | Verifiable<W3CCredential>\n\n/**\n * A union type for both possible representations of a Presentation (JWT and W3C standard)\n *\n * @see https://www.w3.org/TR/vc-data-model/#proof-formats\n */\nexport type VerifiablePresentation = JWT | Verifiable<W3CPresentation>\n\nexport type VerifiedJWT = JWTVerified\n\n/**\n * Represents the result of a Presentation verification.\n * It includes the properties produced by `did-jwt` and a W3C compliant representation of\n * the Presentation that was just verified.\n *\n * This is usually the result of a verification method and not meant to be created by generic code.\n */\nexport type VerifiedPresentation = VerifiedJWT & {\n  verifiablePresentation: Verifiable<W3CPresentation>\n}\n\n/**\n * Represents the result of a Credential verification.\n * It includes the properties produced by `did-jwt` and a W3C compliant representation of\n * the Credential that was just verified.\n *\n * This is usually the result of a verification method and not meant to be created by generic code.\n */\nexport type VerifiedCredential = VerifiedJWT & {\n  verifiableCredential: Verifiable<W3CCredential>\n}\n\n/**\n * Represents a tuple of a DID-URL with a `Signer` and associated algorithm.\n */\nexport interface Issuer {\n  did: string\n  signer: Signer\n  alg?: string\n}\n\n/**\n * Represents the Creation Options that can be passed to the createVerifiableCredentialJwt method.\n */\nexport interface CreateCredentialOptions extends Partial<JWTOptions> {\n  /**\n   * Determines whether the JSON->JWT transformation will remove the original fields from the input payload.\n   * See https://www.w3.org/TR/vc-data-model/#jwt-encoding\n   *\n   * @default true\n   */\n  removeOriginalFields?: boolean\n\n  /**\n   * Allows including or overriding some header parameters for the resulting JWT.\n   * If the issuer or holder does not list an `alg`, then the one specified in `header` will be used\n   */\n  header?: Partial<JWTHeader>\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\n/**\n * Represents the Verification Options that can be passed to the verifyCredential method.\n * These options are forwarded to the lower level verification code\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type VerifyCredentialOptions = Record<string, any>\n\n/**\n * Represents the Verification Options that can be passed to the verifyPresentation method.\n * The verification will fail if given options are NOT satisfied.\n */\nexport interface VerifyPresentationOptions extends VerifyCredentialOptions {\n  domain?: string\n  challenge?: string\n}\n\n/**\n * Represents the Creation Options that can be passed to the createVerifiablePresentationJwt method.\n */\nexport interface CreatePresentationOptions extends CreateCredentialOptions {\n  domain?: string\n  challenge?: string\n}\n","import {\n  VerifiableCredential,\n  JWT,\n  JwtPresentationPayload,\n  JwtCredentialPayload,\n  JWT_FORMAT,\n  DEFAULT_JWT_PROOF_TYPE,\n  DEFAULT_CONTEXT,\n  DEFAULT_VC_TYPE,\n  CredentialPayload,\n  W3CCredential,\n  Verifiable,\n  PresentationPayload,\n  W3CPresentation,\n} from './types'\nimport { decodeJWT } from 'did-jwt'\n\n/*\n * Additional W3C VC fields:\n * These are defined as optional top-level properties in the W3C spec but are not mapped to top-level JWT names,\n * so they should be moved inside the \"vc\" object when transforming to a JWT.\n * Conversely, they should be moved out of the \"vc\" object when transforming from a JWT to W3C JSON.\n */\nconst additionalPropNames = ['evidence', 'termsOfUse', 'refreshService', 'credentialSchema', 'credentialStatus']\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function asArray(arg: any | any[]): any[] {\n  return Array.isArray(arg) ? arg : [arg]\n}\n\nfunction deepCopy<T>(source: T): T {\n  return Array.isArray(source)\n    ? source.map((item) => deepCopy(item))\n    : source instanceof Date\n    ? new Date(source.getTime())\n    : source && typeof source === 'object'\n    ? Object.getOwnPropertyNames(source).reduce((o, prop) => {\n        Object.defineProperty(o, prop, Object.getOwnPropertyDescriptor(source, prop) as NonNullable<PropertyDescriptor>)\n        o[prop] = deepCopy(source[prop as keyof T])\n        return o\n      }, Object.create(Object.getPrototypeOf(source)))\n    : (source as T)\n}\n\nexport function notEmpty<TValue>(value: TValue | null | undefined): value is TValue {\n  return value !== null && value !== undefined\n}\n\nfunction cleanUndefined<T>(input: T): T {\n  if (typeof input !== 'object') {\n    return input\n  }\n  const obj = { ...input }\n  Object.keys(obj).forEach((key) => obj[key as keyof T] === undefined && delete obj[key as keyof T])\n  return obj\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isLegacyAttestationFormat(payload: Record<string, any>): boolean {\n  // payload is an object and has all the required fields of old attestation format\n  return typeof payload === 'object' && payload.sub && payload.iss && payload.claim && payload.iat\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function attestationToVcFormat(payload: Record<string, any>): JwtCredentialPayload {\n  const { iat, nbf, claim, vc, ...rest } = payload\n  const result: JwtCredentialPayload = {\n    ...rest,\n    nbf: nbf ? nbf : iat,\n    vc: {\n      '@context': [DEFAULT_CONTEXT],\n      type: [DEFAULT_VC_TYPE],\n      credentialSubject: claim,\n    },\n  }\n  if (vc) payload.issVc = vc\n  return result\n}\n\nfunction normalizeJwtCredentialPayload(\n  input: Partial<JwtCredentialPayload>,\n  removeOriginalFields = true\n): W3CCredential {\n  let result: Partial<CredentialPayload> = deepCopy(input)\n\n  if (isLegacyAttestationFormat(input)) {\n    result = attestationToVcFormat(input)\n  }\n\n  // FIXME: handle case when credentialSubject(s) are not object types\n  result.credentialSubject = { ...input.credentialSubject, ...input.vc?.credentialSubject }\n  if (input.sub && !input.credentialSubject?.id && result.credentialSubject) {\n    result.credentialSubject.id = input.sub\n    if (removeOriginalFields) {\n      delete result.sub\n    }\n  }\n  if (removeOriginalFields) {\n    delete result.vc?.credentialSubject\n  }\n\n  if (typeof input.issuer === 'undefined' || typeof input.issuer === 'object') {\n    result.issuer = cleanUndefined({ id: input.iss, ...input.issuer })\n    if (removeOriginalFields && !input.issuer?.id) {\n      delete result.iss\n    }\n  }\n\n  if (!input.id && input.jti) {\n    result.id = result.id || result.jti\n    if (removeOriginalFields) {\n      delete result.jti\n    }\n  }\n\n  const types = [...asArray(result.type), ...asArray(result.vc?.type)].filter(notEmpty)\n  result.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.vc?.type\n  }\n\n  for (const prop of additionalPropNames) {\n    if (input.vc && input.vc[prop]) {\n      if (!result[prop]) {\n        result[prop] = input.vc[prop]\n      }\n      if (removeOriginalFields) {\n        delete result.vc[prop]\n      }\n    }\n  }\n\n  const contextArray: string[] = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vc?.['@context']),\n  ].filter(notEmpty)\n  result['@context'] = [...new Set(contextArray)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result.vc?.['@context']\n  }\n\n  if (!input.issuanceDate && (input.iat || input.nbf)) {\n    result.issuanceDate = new Date((input.nbf || input.iat) * 1000).toISOString()\n    if (removeOriginalFields) {\n      if (input.nbf) {\n        delete result.nbf\n      } else {\n        delete result.iat\n      }\n    }\n  }\n\n  if (!input.expirationDate && input.exp) {\n    result.expirationDate = new Date(input.exp * 1000).toISOString()\n    if (removeOriginalFields) {\n      delete result.exp\n    }\n  }\n\n  if (removeOriginalFields) {\n    if (result.vc && Object.keys(result.vc).length === 0) {\n      delete result.vc\n    }\n  }\n\n  // FIXME: interpret `aud` property as `verifier`\n\n  return result as W3CCredential\n}\n\nfunction normalizeJwtCredential(input: JWT, removeOriginalFields = true): Verifiable<W3CCredential> {\n  let decoded\n  try {\n    decoded = decodeJWT(input)\n  } catch (e) {\n    throw new TypeError('unknown credential format')\n  }\n  return {\n    ...normalizeJwtCredentialPayload(decoded.payload, removeOriginalFields),\n    proof: {\n      type: DEFAULT_JWT_PROOF_TYPE,\n      jwt: input,\n    },\n  }\n}\n\n/**\n * Normalizes a credential payload into an unambiguous W3C credential data type\n * In case of conflict, Existing W3C Credential specific properties take precedence,\n * except for arrays and object types which get merged.\n * @param input either a JWT or JWT payload, or a VerifiableCredential\n */\nexport function normalizeCredential(\n  input: Partial<VerifiableCredential> | Partial<JwtCredentialPayload>,\n  removeOriginalFields = true\n): Verifiable<W3CCredential> {\n  if (typeof input === 'string') {\n    if (JWT_FORMAT.test(input)) {\n      return normalizeJwtCredential(input, removeOriginalFields)\n    } else {\n      let parsed: Record<string, unknown>\n      try {\n        parsed = JSON.parse(input)\n      } catch (e) {\n        throw new TypeError('unknown credential format')\n      }\n      return normalizeCredential(parsed, removeOriginalFields)\n    }\n  } else if (input.proof?.jwt) {\n    // TODO: test that it correctly propagates app specific proof properties\n    return deepCopy({ ...normalizeJwtCredential(input.proof.jwt, removeOriginalFields), proof: input.proof })\n  } else {\n    // TODO: test that it accepts JWT payload, CredentialPayload, VerifiableCredential\n    // TODO: test that it correctly propagates proof, if any\n    return { proof: {}, ...normalizeJwtCredentialPayload(input, removeOriginalFields) }\n  }\n}\n\n/**\n * type used to signal a very loose input is accepted\n */\ntype DeepPartial<T> = T extends Record<string, unknown> ? { [K in keyof T]?: DeepPartial<T[K]> } : T\n\n/**\n * Transforms a W3C Credential payload into a JWT compatible encoding.\n * The method accepts app specific fields and in case of collision, existing JWT properties will take precedence.\n * Also, `nbf`, `exp` and `jti` properties can be explicitly set to `undefined` and they will be kept intact.\n * @param input either a JWT payload or a CredentialPayloadInput\n */\nexport function transformCredentialInput(\n  input: Partial<CredentialPayload> | DeepPartial<JwtCredentialPayload>,\n  removeOriginalFields = true\n): JwtCredentialPayload {\n  if (Array.isArray(input.credentialSubject)) throw Error('credentialSubject of type array not supported')\n\n  const result: Partial<JwtCredentialPayload> = deepCopy({\n    vc: { ...input.vc },\n    ...input,\n  }) as Partial<JwtCredentialPayload>\n  result.vc = result.vc as NonNullable<typeof result.vc>\n\n  const credentialSubject = { ...input.credentialSubject, ...input.vc?.credentialSubject }\n  if (!input.sub) {\n    result.sub = input.credentialSubject?.id\n    if (removeOriginalFields) {\n      delete credentialSubject.id\n    }\n  }\n\n  const contextEntries = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vc?.['@context']),\n  ].filter(notEmpty)\n  result.vc['@context'] = [...new Set(contextEntries)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result['@context']\n  }\n\n  const types = [...asArray(input.type), ...asArray(input.vc?.type)].filter(notEmpty)\n  result.vc.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.type\n  }\n\n  if (input.id && Object.getOwnPropertyNames(input).indexOf('jti') === -1) {\n    result.jti = input.id\n    if (removeOriginalFields) {\n      delete result.id\n    }\n  }\n\n  if (input.issuanceDate && Object.getOwnPropertyNames(input).indexOf('nbf') === -1) {\n    const converted = Date.parse(input.issuanceDate)\n    if (!isNaN(converted)) {\n      result.nbf = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.issuanceDate\n      }\n    }\n  }\n\n  if (input.expirationDate && Object.getOwnPropertyNames(input).indexOf('exp') === -1) {\n    const converted = Date.parse(input.expirationDate)\n    if (!isNaN(converted)) {\n      result.exp = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.expirationDate\n      }\n    }\n  }\n\n  if (input.issuer && Object.getOwnPropertyNames(input).indexOf('iss') === -1) {\n    if (typeof input.issuer === 'object') {\n      result.iss = input.issuer?.id\n      if (removeOriginalFields) {\n        delete result.issuer.id\n        if (Object.keys(result.issuer).length === 0) {\n          delete result.issuer\n        }\n      }\n    } else if (typeof input.issuer === 'string') {\n      result.iss = input.iss || '' + input.issuer\n      if (removeOriginalFields) {\n        delete result.issuer\n      }\n    } else {\n      // nop\n    }\n  }\n\n  result.vc.credentialSubject = credentialSubject\n  if (removeOriginalFields) {\n    delete result.credentialSubject\n  }\n\n  for (const prop of additionalPropNames) {\n    if (input[prop]) {\n      if (!result.vc[prop]) {\n        result.vc[prop] = input[prop]\n      }\n      if (removeOriginalFields) {\n        delete result[prop]\n      }\n    }\n  }\n\n  return result as JwtCredentialPayload\n}\n\nfunction normalizeJwtPresentationPayload(\n  input: DeepPartial<JwtPresentationPayload>,\n  removeOriginalFields = true\n): W3CPresentation {\n  const result: Partial<PresentationPayload> = deepCopy(input)\n\n  result.verifiableCredential = [\n    ...asArray(input.verifiableCredential),\n    ...asArray(input.vp?.verifiableCredential),\n  ].filter(notEmpty)\n  result.verifiableCredential = result.verifiableCredential.map((cred) => {\n    return normalizeCredential(cred, removeOriginalFields)\n  })\n  if (removeOriginalFields) {\n    delete result.vp?.verifiableCredential\n  }\n\n  if (input.iss && !input.holder) {\n    result.holder = input.iss\n    if (removeOriginalFields) {\n      delete result.iss\n    }\n  }\n\n  if (input.aud) {\n    result.verifier = [...asArray(input.verifier), ...asArray(input.aud)].filter(notEmpty)\n    result.verifier = [...new Set(result.verifier)]\n    if (removeOriginalFields) {\n      delete result.aud\n    }\n  }\n\n  if (input.jti && Object.getOwnPropertyNames(input).indexOf('id') === -1) {\n    result.id = input.id || input.jti\n    if (removeOriginalFields) {\n      delete result.jti\n    }\n  }\n\n  const types = [...asArray(input.type), ...asArray(input.vp?.type)].filter(notEmpty)\n  result.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.vp?.type\n  }\n\n  const contexts = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vp?.['@context']),\n  ].filter(notEmpty)\n  result['@context'] = [...new Set(contexts)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result.vp?.['@context']\n  }\n\n  if (!input.issuanceDate && (input.iat || input.nbf)) {\n    result.issuanceDate = new Date((input.nbf || input.iat) * 1000).toISOString()\n    if (removeOriginalFields) {\n      if (input.nbf) {\n        delete result.nbf\n      } else {\n        delete result.iat\n      }\n    }\n  }\n\n  if (!input.expirationDate && input.exp) {\n    result.expirationDate = new Date(input.exp * 1000).toISOString()\n    if (removeOriginalFields) {\n      delete result.exp\n    }\n  }\n\n  if (result.vp && Object.keys(result.vp).length === 0) {\n    if (removeOriginalFields) {\n      delete result.vp\n    }\n  }\n\n  return result as W3CPresentation\n}\n\nfunction normalizeJwtPresentation(input: JWT, removeOriginalFields = true): Verifiable<W3CPresentation> {\n  let decoded\n  try {\n    decoded = decodeJWT(input)\n  } catch (e) {\n    throw new TypeError('unknown presentation format')\n  }\n  return {\n    ...normalizeJwtPresentationPayload(decoded.payload, removeOriginalFields),\n    proof: {\n      type: DEFAULT_JWT_PROOF_TYPE,\n      jwt: input,\n    },\n  }\n}\n\n/**\n * Normalizes a presentation payload into an unambiguous W3C Presentation data type\n * @param input either a JWT or JWT payload, or a VerifiablePresentation\n */\nexport function normalizePresentation(\n  input: Partial<PresentationPayload> | DeepPartial<JwtPresentationPayload> | JWT,\n  removeOriginalFields = true\n): Verifiable<W3CPresentation> {\n  if (typeof input === 'string') {\n    if (JWT_FORMAT.test(input)) {\n      return normalizeJwtPresentation(input, removeOriginalFields)\n    } else {\n      let parsed: Record<string, unknown>\n      try {\n        parsed = JSON.parse(input)\n      } catch (e) {\n        throw new TypeError('unknown presentation format')\n      }\n      return normalizePresentation(parsed, removeOriginalFields)\n    }\n  } else if (input.proof?.jwt) {\n    // TODO: test that it correctly propagates app specific proof properties\n    return { ...normalizeJwtPresentation(input.proof.jwt, removeOriginalFields), proof: input.proof }\n  } else {\n    // TODO: test that it accepts JWT payload, PresentationPayload, VerifiablePresentation\n    // TODO: test that it correctly propagates proof, if any\n    return { proof: {}, ...normalizeJwtPresentationPayload(input, removeOriginalFields) }\n  }\n}\n\n/**\n * Transforms a W3C Presentation payload into a JWT compatible encoding.\n * The method accepts app specific fields and in case of collision, existing JWT properties will take precedence.\n * Also, `nbf`, `exp` and `jti` properties can be explicitly set to `undefined` and they will be kept intact.\n * @param input either a JWT payload or a CredentialPayloadInput\n */\nexport function transformPresentationInput(\n  input: Partial<PresentationPayload> | DeepPartial<JwtPresentationPayload>,\n  removeOriginalFields = true\n): JwtPresentationPayload {\n  const result: Partial<JwtPresentationPayload> = deepCopy({\n    vp: { ...input.vp },\n    ...input,\n  }) as Partial<JwtPresentationPayload>\n  result.vp = result.vp as NonNullable<typeof result.vp>\n\n  const contextEntries = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vp?.['@context']),\n  ].filter(notEmpty)\n  result.vp['@context'] = [...new Set(contextEntries)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result['@context']\n  }\n\n  const types = [...asArray(input.type), ...asArray(input.vp?.type)].filter(notEmpty)\n  result.vp.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.type\n  }\n\n  if (input.id && Object.getOwnPropertyNames(input).indexOf('jti') === -1) {\n    result.jti = input.id\n    if (removeOriginalFields) {\n      delete result.id\n    }\n  }\n\n  if (input.issuanceDate && Object.getOwnPropertyNames(input).indexOf('nbf') === -1) {\n    const converted = Date.parse(input.issuanceDate)\n    if (!isNaN(converted)) {\n      result.nbf = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.issuanceDate\n      }\n    }\n  }\n\n  if (input.expirationDate && Object.getOwnPropertyNames(input).indexOf('exp') === -1) {\n    const converted = Date.parse(input.expirationDate)\n    if (!isNaN(converted)) {\n      result.exp = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.expirationDate\n      }\n    }\n  }\n\n  if (result.verifiableCredential || result.vp?.verifiableCredential) {\n    result.vp.verifiableCredential = [\n      ...asArray(result.verifiableCredential),\n      ...asArray(result.vp?.verifiableCredential),\n    ]\n      .filter(notEmpty)\n      .map((credential: VerifiableCredential) => {\n        if (typeof credential === 'object' && credential.proof?.jwt) {\n          return credential.proof.jwt\n        } else {\n          return credential\n        }\n      })\n  }\n\n  if (removeOriginalFields) {\n    delete result.verifiableCredential\n  }\n\n  if (input.holder && Object.getOwnPropertyNames(input).indexOf('iss') === -1) {\n    if (typeof input.holder === 'string') {\n      result.iss = input.holder\n      if (removeOriginalFields) {\n        delete result.holder\n      }\n    } else {\n      // nop\n    }\n  }\n\n  if (input.verifier) {\n    const audience = [...asArray(input.verifier), ...asArray(input.aud)].filter(notEmpty)\n    result.aud = [...new Set(audience)]\n    if (removeOriginalFields) {\n      delete result.verifier\n    }\n  }\n\n  return result as JwtPresentationPayload\n}\n","import { DEFAULT_CONTEXT, DEFAULT_VC_TYPE, DEFAULT_VP_TYPE, JWT_FORMAT } from './types'\nimport { JwtCredentialSubject, DateType } from './types'\nimport { VerifiableCredential } from '.'\nimport { asArray } from './converters'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isDateObject(input: any): input is Date {\n  return input && !isNaN(input) && Object.prototype.toString.call(input) === '[object Date]'\n}\n\nexport function validateJwtFormat(value: VerifiableCredential): void {\n  if (typeof value === 'string' && !value.match(JWT_FORMAT)) {\n    throw new TypeError(`\"${value}\" is not a valid JWT format`)\n  }\n}\n\n// The main scenario we want to guard against is having a timestamp in milliseconds\n// instead of seconds (ex: from new Date().getTime()).\n// We will check the number of digits and assume that any number with 12 or more\n// digits is a millisecond timestamp.\n// 10 digits max is 9999999999 -> 11/20/2286 @ 5:46pm (UTC)\n// 11 digits max is 99999999999 -> 11/16/5138 @ 9:46am (UTC)\n// 12 digits max is 999999999999 -> 09/27/33658 @ 1:46am (UTC)\nexport function validateTimestamp(value: number | DateType): void {\n  if (typeof value === 'number') {\n    if (!(Number.isInteger(value) && value < 100000000000)) {\n      throw new TypeError(`\"${value}\" is not a unix timestamp in seconds`)\n    }\n  } else if (typeof value === 'string') {\n    validateTimestamp(Math.floor(new Date(value).valueOf() / 1000))\n  } else if (!isDateObject(value)) {\n    throw new TypeError(`\"${value}\" is not a valid time`)\n  }\n}\n\nexport function validateContext(value: string | string[]): void {\n  const input = asArray(value)\n  if (input.length < 1 || input.indexOf(DEFAULT_CONTEXT) === -1) {\n    throw new TypeError(`@context is missing default context \"${DEFAULT_CONTEXT}\"`)\n  }\n}\n\nexport function validateVcType(value: string | string[]): void {\n  const input = asArray(value)\n  if (input.length < 1 || input.indexOf(DEFAULT_VC_TYPE) === -1) {\n    throw new TypeError(`type is missing default \"${DEFAULT_VC_TYPE}\"`)\n  }\n}\n\nexport function validateVpType(value: string | string[]): void {\n  const input = asArray(value)\n  if (input.length < 1 || input.indexOf(DEFAULT_VP_TYPE) === -1) {\n    throw new TypeError(`type is missing default \"${DEFAULT_VP_TYPE}\"`)\n  }\n}\n\nexport function validateCredentialSubject(value: JwtCredentialSubject): void {\n  if (Object.keys(value).length === 0) {\n    throw new TypeError('credentialSubject must not be empty')\n  }\n}\n","\nimport { Resolvable } from 'did-resolver'\nimport * as validators from './validators'\nimport {\n  JwtCredentialPayload,\n  Issuer,\n  JwtPresentationPayload,\n  JWT,\n  VerifiablePresentation,\n  VerifiableCredential,\n  CredentialPayload,\n  PresentationPayload,\n  Verifiable,\n  W3CCredential,\n  W3CPresentation,\n  VerifiedCredential,\n  VerifiedPresentation,\n  VerifyPresentationOptions,\n  CreatePresentationOptions,\n  CreateCredentialOptions,\n  VerifyCredentialOptions,\n  JWT_ALG,\n} from './types'\nimport {\n  transformCredentialInput,\n  transformPresentationInput,\n  normalizeCredential,\n  normalizePresentation,\n  asArray,\n  notEmpty,\n} from './converters'\nexport {\n  Issuer,\n  CredentialPayload,\n  PresentationPayload,\n  JwtCredentialPayload,\n  JwtPresentationPayload,\n  VerifiableCredential,\n  VerifiablePresentation,\n  VerifiedCredential,\n  VerifiedPresentation,\n  Verifiable,\n  W3CCredential,\n  W3CPresentation,\n  transformCredentialInput,\n  transformPresentationInput,\n  normalizeCredential,\n  normalizePresentation,\n}\nimport { createJWT, verifyJWT } from 'did-jwt'\n/**\n * Creates a VerifiableCredential given a `CredentialPayload` or `JwtCredentialPayload` and an `Issuer`.\n *\n * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)\n * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the minimum spec\n * required spec.\n *\n * The `issuer` is then used to assign an algorithm, override the `iss` field of the payload and then sign the JWT.\n *\n * @param payload `CredentialPayload` or `JwtCredentialPayload`\n * @param issuer `Issuer` the DID, signer and algorithm that will sign the token\n * @return a `Promise` that resolves to the JWT encoded verifiable credential or rejects with `TypeError` if the\n * `payload` is not W3C compliant\n */\nexport async function createVerifiableCredentialJwt(\n  payload: JwtCredentialPayload | CredentialPayload,\n  issuer: Issuer,\n  options: CreateCredentialOptions = {}\n): Promise<JWT> {\n  const parsedPayload: JwtCredentialPayload = {\n    iat: undefined,\n    ...transformCredentialInput(payload, options.removeOriginalFields),\n  }\n  validateJwtCredentialPayload(parsedPayload)\n  return createJWT(\n    parsedPayload,\n    {\n      ...options,\n      issuer: issuer.did || parsedPayload.iss || '',\n      signer: issuer.signer,\n    },\n    {\n      ...options.header,\n      alg: issuer.alg || options.header?.alg || JWT_ALG,\n    }\n  )\n}\n\n/**\n * Creates a VerifiablePresentation JWT given a `PresentationPayload` or `JwtPresentationPayload` and an `Issuer`.\n *\n * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)\n * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the minimum spec\n * required spec.\n *\n * The `holder` is then used to assign an algorithm, override the `iss` field of the payload and then sign the JWT.\n *\n * @param payload `PresentationPayload` or `JwtPresentationPayload`\n * @param holder `Issuer` of the Presentation JWT (holder of the VC), signer and algorithm that will sign the token\n * @param options `CreatePresentationOptions` allows to pass additional values to the resulting JWT payload\n * @return a `Promise` that resolves to the JWT encoded verifiable presentation or rejects with `TypeError` if the\n * `payload` is not W3C compliant\n */\nexport async function createVerifiablePresentationJwt(\n  payload: JwtPresentationPayload | PresentationPayload,\n  holder: Issuer,\n  options: CreatePresentationOptions = {}\n): Promise<JWT> {\n  const parsedPayload: JwtPresentationPayload = {\n    iat: undefined,\n    ...transformPresentationInput(payload, options?.removeOriginalFields),\n  }\n\n  // add challenge to nonce\n  if (options.challenge && Object.getOwnPropertyNames(parsedPayload).indexOf('nonce') === -1) {\n    parsedPayload.nonce = options.challenge\n  }\n\n  // add domain to audience.\n  if (options.domain) {\n    const audience = [...asArray(options.domain), ...asArray(parsedPayload.aud)].filter(notEmpty)\n    parsedPayload.aud = [...new Set(audience)]\n  }\n\n  validateJwtPresentationPayload(parsedPayload)\n  return createJWT(\n    parsedPayload,\n    {\n      ...options,\n      issuer: holder.did || parsedPayload.iss || '',\n      signer: holder.signer,\n    },\n    {\n      ...options.header,\n      alg: holder.alg || options.header?.alg || JWT_ALG,\n    }\n  )\n}\n\nexport function validateJwtCredentialPayload(payload: JwtCredentialPayload): void {\n  validators.validateContext(payload.vc['@context'])\n  validators.validateVcType(payload.vc.type)\n  validators.validateCredentialSubject(payload.vc.credentialSubject)\n  if (payload.nbf) validators.validateTimestamp(payload.nbf)\n  if (payload.exp) validators.validateTimestamp(payload.exp)\n}\n\nexport function validateCredentialPayload(payload: CredentialPayload): void {\n  validators.validateContext(payload['@context'])\n  validators.validateVcType(payload.type)\n  validators.validateCredentialSubject(payload.credentialSubject)\n  if (payload.issuanceDate) validators.validateTimestamp(payload.issuanceDate)\n  if (payload.expirationDate) validators.validateTimestamp(payload.expirationDate)\n}\n\nexport function validateJwtPresentationPayload(payload: JwtPresentationPayload): void {\n  validators.validateContext(payload.vp['@context'])\n  validators.validateVpType(payload.vp.type)\n  // empty credential array is allowed\n  if (payload.vp.verifiableCredential && payload.vp.verifiableCredential.length >= 1) {\n    for (const vc of asArray(payload.vp.verifiableCredential)) {\n      if (typeof vc === 'string') {\n        validators.validateJwtFormat(vc)\n      } else {\n        validateCredentialPayload(vc)\n      }\n    }\n  }\n  if (payload.exp) validators.validateTimestamp(payload.exp)\n}\n\nexport function validatePresentationPayload(payload: PresentationPayload): void {\n  validators.validateContext(payload['@context'])\n  validators.validateVpType(payload.type)\n  // empty credential array is allowed\n  if (payload.verifiableCredential && payload.verifiableCredential.length >= 1) {\n    for (const vc of payload.verifiableCredential) {\n      if (typeof vc === 'string') {\n        validators.validateJwtFormat(vc)\n      } else {\n        validateCredentialPayload(vc)\n      }\n    }\n  }\n  if (payload.expirationDate) validators.validateTimestamp(payload.expirationDate)\n}\n\n/**\n * Verifies and validates a VerifiableCredential that is encoded as a JWT according to the W3C spec.\n *\n * @return a `Promise` that resolves to a `VerifiedCredential` or rejects with `TypeError` if the input is not\n * W3C compliant\n * @param vc the credential to be verified. Currently only the JWT encoding is supported by this library\n * @param resolver a configured `Resolver` (or an implementation of `Resolvable`) that can provide the DID document of the JWT issuer\n */\nexport async function verifyCredential(\n  vc: JWT,\n  resolver: Resolvable,\n  options: VerifyCredentialOptions = {}\n): Promise<VerifiedCredential> {\n  const verified: Partial<VerifiedCredential> = await verifyJWT(vc, { resolver, ...options })\n  verified.verifiableCredential = normalizeCredential(verified.jwt as string, options?.removeOriginalFields)\n  validateCredentialPayload(verified.verifiableCredential)\n  return verified as VerifiedCredential\n}\n\n/**\n * Verifies that the given JwtPresentationPayload contains the appropriate options from VerifyPresentationOptions\n *\n * @param payload the JwtPresentationPayload to verify against\n * @param options the VerifyPresentationOptions that contain the optional values to verify.\n * @throws {Error} If VerifyPresentationOptions are not satisfied\n */\nexport function verifyPresentationPayloadOptions(\n  payload: JwtPresentationPayload,\n  options: VerifyPresentationOptions\n): void {\n  if (options.challenge && options.challenge !== payload.nonce) {\n    throw new Error(`Presentation does not contain the mandatory challenge (JWT: nonce) for : ${options.challenge}`)\n  }\n\n  if (options.domain) {\n    // aud might be array\n    let matchedAudience\n    if (payload.aud) {\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud]\n      matchedAudience = audArray.find((item) => options.domain === item)\n    }\n\n    if (typeof matchedAudience === 'undefined') {\n      throw new Error(`Presentation does not contain the mandatory domain (JWT: aud) for : ${options.domain}`)\n    }\n  }\n}\n\n/**\n * Verifies and validates a VerifiablePresentation that is encoded as a JWT according to the W3C spec.\n *\n * @return a `Promise` that resolves to a `VerifiedPresentation` or rejects with `TypeError` if the input is\n * not W3C compliant or the VerifyPresentationOptions are not satisfied.\n * @param presentation the presentation to be verified. Currently only the JWT encoding is supported by this library\n * @param resolver a configured `Resolver` or an implementation of `Resolvable` that can provide the DID document of the JWT issuer (presentation holder)\n * @param options optional verification options that need to be satisfied\n */\nexport async function verifyPresentation(\n  presentation: JWT,\n  resolver: Resolvable,\n  options: VerifyPresentationOptions = {}\n): Promise<VerifiedPresentation> {\n  const verified: Partial<VerifiedPresentation> = await verifyJWT(presentation, { resolver, ...options })\n  verifyPresentationPayloadOptions(verified.payload as JwtPresentationPayload, options)\n  verified.verifiablePresentation = normalizePresentation(verified.jwt as string, options?.removeOriginalFields)\n  validatePresentationPayload(verified.verifiablePresentation)\n  return verified as VerifiedPresentation\n}\n"],"names":["JWT_ALG","JWT_FORMAT","DEFAULT_CONTEXT","DEFAULT_VC_TYPE","DEFAULT_VP_TYPE","DEFAULT_JWT_PROOF_TYPE","additionalPropNames","asArray","arg","Array","isArray","deepCopy","source","map","item","Date","getTime","Object","getOwnPropertyNames","reduce","o","prop","defineProperty","getOwnPropertyDescriptor","create","getPrototypeOf","notEmpty","value","normalizeJwtCredentialPayload","input","removeOriginalFields","result","payload","sub","iss","claim","iat","nbf","vc","rest","type","credentialSubject","issVc","attestationToVcFormat","id","issuer","obj","keys","forEach","key","undefined","cleanUndefined","jti","types","filter","Set","contextArray","context","issuanceDate","toISOString","expirationDate","exp","length","normalizeJwtCredential","decoded","decodeJWT","e","TypeError","proof","jwt","normalizeCredential","test","parsed","JSON","parse","transformCredentialInput","Error","contextEntries","indexOf","converted","isNaN","Math","floor","normalizeJwtPresentationPayload","verifiableCredential","vp","cred","holder","aud","verifier","contexts","normalizeJwtPresentation","normalizePresentation","transformPresentationInput","credential","audience","validateJwtFormat","match","validateTimestamp","Number","isInteger","valueOf","prototype","toString","call","validateContext","validateVcType","validateVpType","validateCredentialSubject","validateJwtCredentialPayload","validators","validateCredentialPayload","validateJwtPresentationPayload","validatePresentationPayload","verifyPresentationPayloadOptions","options","challenge","nonce","domain","matchedAudience","find","parsedPayload","createJWT","did","signer","header","alg","resolver","verifyJWT","verified","presentation","verifiablePresentation"],"mappings":"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"}